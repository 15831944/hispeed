using System;
using System.Collections.Generic;
using System.Text;
using System.Windows.Forms;
using System.Drawing;
using System.Diagnostics;
using System.ComponentModel;
using Telerik.WinControls.UI;

namespace Telerik.WinControls.UI.Docking
{
    /// <summary>
    /// Encapsulates the core drag-and-drop functionality for a RadDock instance.
    /// What RadDock does is to start and stop the service when drag operation is instanciated.
    /// </summary>
    public class DragDropService : StateService, IMessageListener
    {
        #region Constructor

        /// <summary>
        /// Default constructor.
        /// </summary>
        public DragDropService()
        {
            this.dragMode = DragDropMode.Auto;
            this.allowedStates = AllowedDockState.All;
            this.dockManagerEdges = AllowedDockPosition.All;
            this.behavior = DragDropBehavior.Auto;
        }

        static DragDropService()
        {
            Type t = typeof(DragDropService);
            string path = "Telerik.WinControls.UI.Docking.Resources.";
            DocumentDragValid = ResourceHelper.CursorFromResource(t, path + "DocumentValid.cur");
            DocumentDragInvalid = ResourceHelper.CursorFromResource(t, path + "DocumentInvalid.cur");
            DraggingEventKey = new object();
            HitTestEventKey = new object();
            DragDropTargetEventKey = new object();
            AllowedDockPositionEventKey = new object();
            GuidesRecreatedEventKey = new object();
        }

        #endregion

        #region Interfaces

        #region IMessageListener Members

        InstalledHook IMessageListener.DesiredHook
        {
            get 
            {
                return InstalledHook.CallWndProc | InstalledHook.GetMessage;
            }
        }

        MessagePreviewResult IMessageListener.PreviewMessage(ref Message msg)
        {
            ServiceState state = this.State;
            if (state == ServiceState.Stopped || state == ServiceState.Initial)
            {
                RadMessageFilter.Instance.RemoveListener(this);
                this.messageFilterAdded = false;
                return MessagePreviewResult.NotProcessed;
            }

            int message = msg.Msg;
            Keys modifyKeys = (Keys)msg.WParam.ToInt32();

            switch (message)
            {
                case NativeMethods.WM_KEYDOWN:
                case NativeMethods.WM_SYSKEYDOWN:
                    if (modifyKeys == Keys.Escape)
                    {
                        this.Stop(false);
                        return MessagePreviewResult.ProcessedNoDispatch;
                    }
                    break;
                case NativeMethods.WM_MOUSEMOVE:
                case NativeMethods.WM_MOVING:
                    try
                    {
                        this.Drag(Control.MousePosition);
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine(ex.Message);
                    }
                    return MessagePreviewResult.ProcessedNoDispatch;
                case NativeMethods.WM_NCLBUTTONUP:
                case NativeMethods.WM_LBUTTONUP:
                    this.Stop(true);
                    return MessagePreviewResult.ProcessedNoDispatch;
            }

            return MessagePreviewResult.NotProcessed;
        }

        void IMessageListener.PreviewWndProc(Message msg)
        {
            if (msg.Msg == NativeMethods.WM_ACTIVATEAPP)
            {
                this.Stop(false);
            }
        }

        void IMessageListener.PreviewSystemMessage(SystemMessage message, Message msg)
        {
            throw new NotImplementedException();
        }

        #endregion

        #endregion

        #region Events

        /// <summary>
        /// Notifies for a Drag event of the service. While working, this notification will be raised upon each mouse move event.
        /// </summary>
        public event CancelEventHandler Dragging
        {
            add
            {
                this.Events.AddHandler(DraggingEventKey, value);
            }
            remove
            {
                this.Events.RemoveHandler(DraggingEventKey, value);
            }
        }

        /// <summary>
        /// Allows listeners to preview and optionally change the current hit-test result generated by the service upon a drag operation.
        /// </summary>
        public event DragDropHitTestEventHandler PreviewHitTest
        {
            add
            {
                this.Events.AddHandler(HitTestEventKey, value);
            }
            remove
            {
                this.Events.RemoveHandler(HitTestEventKey, value);
            }
        }

        /// <summary>
        /// Allows listeners to preview and optionally change the currently hit-tested drop target.
        /// </summary>
        public event DragDropTargetEventHandler PreviewDropTarget
        {
            add
            {
                this.Events.AddHandler(DragDropTargetEventKey, value);
            }
            remove
            {
                this.Events.RemoveHandler(DragDropTargetEventKey, value);
            }
        }

        /// <summary>
        /// Allows listeners to preview and optionally modify the allowed dock position for the hit-tested drop target.
        /// </summary>
        public event DragDropDockPositionEventHandler PreviewDockPosition
        {
            add
            {
                this.Events.AddHandler(AllowedDockPositionEventKey, value);
            }
            remove
            {
                this.Events.RemoveHandler(AllowedDockPositionEventKey, value);
            }
        }

        #endregion

        #region Overrides

        /// <summary>
        /// Drag-and-drop service is available at design-time (in preview mode only).
        /// </summary>
        public override bool AvailableAtDesignTime
        {
            get
            {
                return true;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void DisposeManagedResources()
        {
            if (this.dockingGuides != null)
            {
                foreach (DockingGuidePopup popup in this.dockingGuides)
                {
                    popup.Dispose();
                }
                this.dockingGuides = null;
            }
            if (this.hintPopup != null)
            {
                this.hintPopup.Dispose();
                this.hintPopup = null;
            }

            base.DisposeManagedResources();
        }

        /// <summary>
        /// 
        /// </summary>
        protected override void OnDockManagerChanged()
        {
            base.OnDockManagerChanged();

            this.RecreateGuides();
        }

        /// <summary>
        /// Determines whether the provides context is valid and a drag-drop operation may be instanciated.
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        protected override bool IsContextValid(object context)
        {
            return (context is IDockWindow ||
                    context is DockTabStrip ||
                    context is FloatingWindow);
        }

        /// <summary>
        /// Determines whether the service can start using the provided context.
        /// </summary>
        /// <param name="context"></param>
        /// <returns></returns>
        protected override bool CanStart(object context)
        {
            if(!base.CanStart(context))
            {
                return false;
            }

            this.dragContext = this.GetDragDropContext(context);
            if (dragContext == DragDropContext.Invalid)
            {
                return false;
            }

            this.currentDragMode = this.GetDragMode(context);

            bool canStart = false;
            switch(this.currentDragMode)
            {
                case DragDropMode.Preview:
                    canStart = this.CanStartPreviewDrag(context);
                    break;
                case DragDropMode.Immediate:
                    canStart = this.CanStartImmediateDrag(context);
                    break;
            }

            return canStart;
        }

        /// <summary>
        /// Preforms the core start process.
        /// </summary>
        protected override void PerformStart()
        {
            this.UpdateAllowedDockStates();

            RadDock dockManager = this.DockManager;
            dockManager.BeginTransactionBlock(true);

            //release current capture
            if (this.behavior == DragDropBehavior.Auto)
            {
                NativeMethods.ReleaseCapture();
            }

            //remember initial mouse position
            if (this.dragStart == null)
            {
                this.dragStart = Control.MousePosition;
            }

            //examine the drag mode
            switch(this.currentDragMode)
            {
                case DragDropMode.Immediate:
                    //examine the drag context
                    if(this.dragContext == DragDropContext.FloatingWindow)
                    {
                        this.draggedWindow = this.Context as FloatingWindow;
                        this.draggedPaneInitialLocation = this.draggedWindow.Location;
                    }
                    else
                    {
                        this.MakeFloating(this.Context);
                        //having no dragged window means that none of the associated windows may become floating
                        if (this.draggedWindow == null)
                        {
                            dockManager.EndTransactionBlock();
                            this.Stop(false);
                            return;
                        }
                    }
                    break;
                case DragDropMode.Preview:
                    this.dragPreview.DesiredSize = this.GetFloatingSize(this.Context);
                    this.draggedPaneInitialLocation = this.GetFloatingLocation(this.Context, this.dragPreview.DesiredSize);
                    break;
            }

            Control toCapture = null;
            if (this.draggedWindow != null)
            {
                //display the floating pane
                this.draggedWindow.Show();
                this.draggedWindow.BringToFront();
                this.draggedWindow.SetDragged(true);
                toCapture = this.draggedWindow;
            }
            else
            {
                toCapture = this.DockManager;
            }

            //hook application messages
            if (!messageFilterAdded && this.behavior == DragDropBehavior.Auto)
            {
                RadMessageFilter.Instance.AddListener(this);
                messageFilterAdded = true;
                if (toCapture != null)
                {
                    toCapture.Capture = true;
                }
            }

            //perform initial drag
            this.Drag(this.dragStart.Value);

            dockManager.EndTransactionBlock();
        }

        /// <summary>
        /// Performs the core stop process.
        /// </summary>
        protected override void PerformStop()
        {
            //unregister from message previewing
            if (this.messageFilterAdded)
            {
                RadMessageFilter.Instance.RemoveListener(this);
                this.messageFilterAdded = false;
            }

            if (this.dragContext == DragDropContext.DocumentWindow)
            {
                Cursor.Current = Cursors.Default;
            }
            this.dragContext = DragDropContext.Invalid;

            if (this.dragPreview != null)
            {
                this.dragPreview.Hide();
            }

            //reset members
            this.prevMouse = new Point(Int32.MinValue, Int32.MinValue);
            this.HideGuides();
            this.hintPopup.Hide();
            this.dropAnchor = null;
            this.draggedWindow = null;
            this.dragStart = null;

            base.PerformStop();
        }

        /// <summary>
        /// Notifies for a Stop request.
        /// </summary>
        /// <param name="e"></param>
        protected override void OnStopping(StateServiceStoppingEventArgs e)
        {
            base.OnStopping(e);
            if (e.Cancel)
            {
                return;
            }

            Control captured = null;
            if (this.draggedWindow != null)
            {
                this.draggedWindow.SetDragged(false);
                captured = this.draggedWindow;
            }
            else
            {
                captured = this.DockManager;
            }

            if (captured != null && this.behavior == DragDropBehavior.Auto)
            {
                captured.Capture = false;
                NativeMethods.ReleaseCapture();
            }
        }

        /// <summary>
        /// Commits the drag-and-drop operation.
        /// </summary>
        protected override void Commit()
        {
            base.Commit();

            if (this.guideHitTest == DockingGuideHitTest.Empty)
            {
                //if we are in a preview mode, try to float the drag context
                if (this.dragMode == DragDropMode.Preview &&
                    (this.currentAllowedStates & AllowedDockState.Floating) != 0)
                {
                    if (this.Context is FloatingWindow)
                    {
                        (this.Context as FloatingWindow).Location = this.GetDragLocation();
                    }
                    else
                    {
                        this.MakeFloating(this.Context, this.dragPreview.Bounds);
                    }
                }
                return;
            }

            SplitPanel target = null;
            if (this.guideHitTest.GuidePosition == DockingGuidesPosition.Center)
            {
                target = this.dropAnchor;
                if (this.guideHitTest.DockPosition == DockPosition.Fill && 
                    dropAnchor == this.DockManager.MainDocumentContainer &&
                    this.DockManager.MainDocumentContainerVisible)
                {
                    target = this.DockManager.GetDefaultDocumentTabStrip(true);
                }
            }

            this.DockManager.RegisterTransaction(this.CreateTransaction(target), true);
        }

        #endregion

        #region Implementation

        /// <summary>
        /// Gets the current screen bounds for the specified DockingGuide.
        /// </summary>
        /// <param name="position"></param>
        /// <returns></returns>
        public Rectangle GetDockingGuideBounds(DockingGuidesPosition position)
        {
            int index = (int)position;
            if (index < 0 || index > this.dockingGuides.Length - 1)
            {
                return Rectangle.Empty;
            }

            DockingGuidePopup popup = this.dockingGuides[(int)position];
            if (popup.Visible)
            {
                return popup.Bounds;
            }

            return Rectangle.Empty;
        }

        /// <summary>
        /// Gets the allowed position for the currently displayed guide for the specified guide position.
        /// </summary>
        /// <param name="guidePosition">The position of the guide.</param>
        /// <returns></returns>
        public AllowedDockPosition GetDockingGuideAllowedPosition(DockingGuidesPosition guidePosition)
        {
            int index = (int)guidePosition;
            if (index < 0 || index > this.dockingGuides.Length - 1)
            {
                return AllowedDockPosition.None;
            }

            DockingGuidePopup popup = this.dockingGuides[index];
            if (popup.Visible)
            {
                return popup.AllowedDockPosition;
            }

            return AllowedDockPosition.None;
        }

        /// <summary>
        /// Performs a drag pass. Allows for service automation.
        /// The service must be started for this method to execute properly.
        /// </summary>
        /// <param name="screenMousePos">The position of the mouse in screen coordinates.</param>
        public void PerformDrag(Point screenMousePos)
        {
            if (this.State != ServiceState.Working)
            {
                return;
            }

            this.Drag(screenMousePos);
        }

        /// <summary>
        /// Starts the service with the specified context, using the provided Point as initial.
        /// </summary>
        /// <param name="context"></param>
        /// <param name="start"></param>
        public void Start(object context, Point start)
        {
            this.dragStart = start;
            base.Start(context);
        }

        /// <summary>
        /// Receives notification for a change in the current docking guides template.
        /// </summary>
        protected internal virtual void OnDockingGuidesTemplateChanged()
        {
            this.RecreateGuides();
        }

        /// <summary>
        /// Preforms a drag pass, during which a hit-test operation is performed and docking guides and hints are updated respectively.
        /// </summary>
        protected virtual void Drag(Point mousePos)
        {
            //for some reason we are calling a drag method without mouse capture
            if (this.behavior == DragDropBehavior.Auto && NativeMethods.GetCapture() == null)
            {
                this.Stop(false);
                return;
            }

            this.currMouse = mousePos;
            if (this.behavior == DragDropBehavior.Auto && this.currMouse == this.prevMouse)
            {
                return;
            }

            this.prevMouse = this.currMouse;
            if (this.draggedWindow != null)
            {
                this.draggedWindow.BringToFront();
            }

            //update the drop target and docking guides
            this.dropAnchor = this.GetDropTarget();
            this.PositonDockingGuides();

            this.HitTestGuides();
            this.UpdateDockingHint();

            if (this.dragContext == DragDropContext.DocumentWindow)
            {
                this.UpdateDocumentCursor();
            }

            //we are not above a docking guide, move the dragged object
            if (this.guideHitTest == DockingGuideHitTest.Empty)
            {
                this.MoveDraggedObject();
            }

            //raise the Dragging event and check whether we may continue the operation.
            CancelEventArgs args = new CancelEventArgs();
            OnDragging(args);
            if (args.Cancel)
            {
                this.Stop(false);
            }
        }

        /// <summary>
        /// Raises the Dragging notification.
        /// </summary>
        /// <param name="args"></param>
        protected virtual void OnDragging(CancelEventArgs args)
        {
            CancelEventHandler eh = this.Events[DraggingEventKey] as CancelEventHandler;
            if (eh != null)
            {
                eh(this, args);
            }
        }

        /// <summary>
        /// Searches for a drop target under the cursor position. May return null if no appropriate control is found.
        /// </summary>
        /// <returns></returns>
        protected virtual SplitPanel GetDropTarget()
        {
            //hit-test floating windows first
            SplitPanel panel = this.HitTestFloatingWindows();
            if (panel == null)
            {
                panel = this.HitTestDockManager();
            }

            //allow listeners to preview the drop target and optionally modify it
            DragDropTargetEventHandler eh = this.Events[DragDropTargetEventKey] as DragDropTargetEventHandler;
            if (eh != null)
            {
                DragDropTargetEventArgs e = new DragDropTargetEventArgs(panel);
                eh(this, e);
                panel = e.DropTarget;
            }

            return panel;
        }

        /// <summary>
        /// Updates all docking guides' bounds on the screen.
        /// </summary>
        protected virtual void PositonDockingGuides()
        {
            //left, top, bottom and right guides indicate the DockManager as a target
            //they are visible when mouse position is within manager's bounds and we are not dragging a document
            Rectangle contentBounds = this.DockManager.ContentRectangle;
            Rectangle contentScreenBounds = this.DockManager.RectangleToScreen(contentBounds);

            Point mousePos = this.DockManager.PointToClient(this.currMouse);
            bool dockManagerContainsMouse = contentBounds.Contains(mousePos);
            Point location = Point.Empty;

            foreach (DockingGuidePopup popup in this.dockingGuides)
            {
                Size popupSize = popup.DisplaySize;
                location = Point.Empty;

                if (popup.Position == DockingGuidesPosition.Center)
                {
                    if (this.dropAnchor != null)
                    {
                        popup.AllowedDockPosition = this.GetCenterGuideAllowedPosition(popup);
                        if (popup.AllowedDockPosition != AllowedDockPosition.None)
                        {
                            Rectangle dropTargetBounds = this.dropAnchor.Parent.RectangleToScreen(this.dropAnchor.Bounds);
                            location = new Point(dropTargetBounds.X + (dropTargetBounds.Width - popupSize.Width) / 2,
                                                 dropTargetBounds.Y + (dropTargetBounds.Height - popupSize.Height) / 2);
                        }
                    }
                }
                else if(dockManagerContainsMouse)
                {
                    if (this.dragContext == DragDropContext.DocumentWindow &&
                        !this.DockManager.TreatTabbedDocumentsAsToolWindows)
                    {
                        popup.Hide();
                        continue;
                    }

                    if ((this.dockManagerEdges & popup.AllowedDockPosition) != 0)
                    {
                        switch (popup.Position)
                        {
                            case DockingGuidesPosition.Left:
                                location = new Point(contentScreenBounds.X,
                                                     contentScreenBounds.Y + (contentScreenBounds.Height - popupSize.Height) / 2);
                                break;
                            case DockingGuidesPosition.Top:
                                location = new Point(contentScreenBounds.X + (contentScreenBounds.Width - popupSize.Width) / 2,
                                                     contentScreenBounds.Y);
                                break;
                            case DockingGuidesPosition.Bottom:
                                location = new Point(contentScreenBounds.X + (contentScreenBounds.Width - popupSize.Width) / 2,
                                                     contentScreenBounds.Bottom - popupSize.Height);
                                break;
                            case DockingGuidesPosition.Right:
                                location = new Point(contentScreenBounds.Right - popupSize.Width,
                                                     contentScreenBounds.Y + (contentScreenBounds.Height - popupSize.Height) / 2);
                                break;
                        }
                    }
                }

                if (location != Point.Empty)
                {
                    popup.Display(location);
                    popup.BringToFront();
                }
                else
                {
                    popup.Hide();
                }
            }
        }

        /// <summary>
        /// Gets the current location for a dragged object.
        /// The associated object depends on the current drag mode - it may be a FloatingWindow or a DockingHintPopup instance.
        /// </summary>
        /// <returns></returns>
        protected virtual Point GetDragLocation()
        {
            int offsetX = this.currMouse.X - this.dragStart.Value.X;
            int offsetY = this.currMouse.Y - this.dragStart.Value.Y;

            Point newLocation = this.draggedPaneInitialLocation;
            newLocation.Offset(offsetX, offsetY);

            Size dragSize;
            if (this.dragPreview != null)
            {
                dragSize = this.dragPreview.Size;
            }
            else
            {
                Debug.Assert(this.draggedWindow != null, "No valid drag context");
                dragSize = this.draggedWindow.Size;
            }

            return this.EnsureScreenBounds(dragSize, newLocation);
        }

        private Point EnsureScreenBounds(Size dragSize, Point newLocation)
        {
            int edgePadding = 4;
            int frameWidth = SystemInformation.FrameBorderSize.Width;
            Rectangle workingArea = Screen.FromPoint(newLocation).WorkingArea;

            //clamp bottom-right
            newLocation.X = Math.Min(workingArea.Right - (frameWidth + edgePadding), newLocation.X);
            newLocation.Y = Math.Min(workingArea.Bottom - (frameWidth + edgePadding), newLocation.Y);

            //clamp left-top
            newLocation.X = Math.Max(newLocation.X, workingArea.X - dragSize.Width + (frameWidth + edgePadding));
            newLocation.Y = Math.Max(newLocation.Y, workingArea.Y + edgePadding);

            return newLocation;
        }

        private AllowedDockPosition GetCenterGuideAllowedPosition(DockingGuidePopup popup)
        {
            AllowedDockPosition position = AllowedDockPosition.All;

            if (this.dragContext == DragDropContext.DocumentWindow)
            {
                DockWindow window = this.Context as DockWindow;
                if (window.TabStrip == dropAnchor)
                {
                    position &= ~AllowedDockPosition.Fill;
                }
            }
            else if(this.dropAnchor == this.DockManager.MainDocumentContainer)
            {
                if ((this.currentAllowedStates & AllowedDockState.TabbedDocument) == 0)
                {
                    position &= ~AllowedDockPosition.Fill;
                }
            }

            DragDropDockPositionEventHandler eh = this.Events[AllowedDockPositionEventKey] as DragDropDockPositionEventHandler;
            if (eh != null)
            {
                DragDropDockPositionEventArgs e = new DragDropDockPositionEventArgs(this.dropAnchor, position, popup.Position);
                eh(this, e);
                //get the value from the event arguments as the user may have it modified
                position = e.AllowedDockPosition;
            }

            return position;
        }

        private SplitPanel GetDropTargetFromParent(Control parent)
        {
            Point mousePos = this.currMouse;
            Point client;
            object context = this.Context;

            foreach (DockTabStrip strip in ControlHelper.GetChildControls<DockTabStrip>(parent, true))
            {
                if (strip.Collapsed || strip.DockManager != this.DockManager)
                {
                    continue;
                }

                client = strip.PointToClient(mousePos);
                if (!strip.ClientRectangle.Contains(client) || strip == context)
                {
                    continue;
                }

                DockState state = this.DockManager.GetDockState(strip);
                if ((this.currentAllowedStates & DockHelper.GetAllowedDockState(state)) == 0)
                {
                    continue;
                }

                switch(this.dragContext)
                {
                    case DragDropContext.DocumentWindow:
                        if (this.DockManager.TreatTabbedDocumentsAsToolWindows)
                        {
                            break;
                        }

                        if (strip is DocumentTabStrip)
                        {
                            return strip;
                        }

                        continue;
                    default:
                        if (strip is DocumentTabStrip)
                        {
                            if (this.HitTestMainDocumentContainer())
                            {
                                return this.DockManager.MainDocumentContainer;
                            }

                            continue;
                        }

                        return strip;
                }
            }

            return null;
        }

        private bool HitTestMainDocumentContainer()
        {
            if (!this.DockManager.MainDocumentContainerVisible)
            {
                return false;
            }

            //keep in mind nested dock managers
            switch(this.dragContext)
            {
                case DragDropContext.DocumentWindow:
                case DragDropContext.ToolWindow:
                    if(((DockWindow)this.Context).DockManager != this.DockManager)
                    {
                        return false;
                    }
                    break;
                case DragDropContext.ToolTabStrip:
                    if (((ToolTabStrip)this.Context).DockManager != this.DockManager)
                    {
                        return false;
                    }
                    break;
                case DragDropContext.FloatingWindow:
                    if (((FloatingWindow)this.Context).DockManager != this.DockManager)
                    {
                        return false;
                    }
                    break;
            }

            Point client = this.DockManager.MainDocumentContainer.PointToClient(this.currMouse);
            return this.DockManager.MainDocumentContainer.ClientRectangle.Contains(client);
        }

        private void UpdateDocumentCursor()
        {
            if (this.dropAnchor == null)
            {
                Cursor.Current = DocumentDragInvalid;
            }
            else
            {
                Cursor.Current = DocumentDragValid;
            }
        }

        private void MoveDraggedObject()
        {
            if (this.draggedWindow != null)
            {
                this.draggedWindow.Location = this.GetDragLocation();
            }
            else if (this.dragPreview != null)
            {
                this.dragPreview.Location = this.GetDragLocation();
            }
        }

        private SplitPanel HitTestFloatingWindows()
        {
            if ((this.currentAllowedStates & AllowedDockState.Floating) == 0)
            {
                return null;
            }

            Form f = this.DockManager.FindForm();
            if (f == null)
            {
                return null;
            }

            Form[] ownedForms = f.OwnedForms;
            int length = ownedForms.Length;

            SplitPanel target = null;

            for (int i = length - 1; i >= 0; i--)
            {
                FloatingWindow window = ownedForms[i] as FloatingWindow;
                if (window == null || window == this.Context || window == this.draggedWindow)
                {
                    continue;
                }

                target = this.GetDropTargetFromParent(window);
                if (target != null)
                {
                    break;
                }
            }

            return target;
        }

        private SplitPanel HitTestDockManager()
        {
            SplitPanel panel = this.GetDropTargetFromParent(this.DockManager);
            if (panel != null)
            {
                return panel;
            }

            if (this.HitTestMainDocumentContainer())
            {
                return this.DockManager.MainDocumentContainer;
            }

            return null;
        }

        private DragDropContext GetDragDropContext(object context)
        {
            if (context is FloatingWindow)
            {
                return DragDropContext.FloatingWindow;
            }
            if (context is ToolTabStrip)
            {
                return DragDropContext.ToolTabStrip;
            }

            DockWindow window = context as DockWindow;
            Debug.Assert(window != null, "Invalid drag context");
            if (window == null)
            {
                return DragDropContext.Invalid;
            }

            DockTabStrip strip = window.DockTabStrip;
            Debug.Assert(strip != null, "A dragged DockWindow must have a parent DockTabStrip.");
            if (strip == null)
            {
                return DragDropContext.Invalid;
            }

            if (strip is DocumentTabStrip)
            {
                return DragDropContext.DocumentWindow;
            }

            return DragDropContext.ToolWindow;
        }

        private DragDropMode GetDefaultDragMode(object context)
        {
            switch(this.dragContext)
            {
                case DragDropContext.DocumentWindow:
                    return DragDropMode.Preview;
                case DragDropContext.FloatingWindow:
                case DragDropContext.ToolTabStrip:
                case DragDropContext.ToolWindow:
                    return DragDropMode.Immediate;
            }

            throw new InvalidOperationException("Invalid drag-drop context\r\n" + context);
        }

        private DragDropMode GetDragMode(object context)
        {
            if (this.DockManagerDesignMode)
            {
                return DragDropMode.Preview;
            }

            DragDropMode mode = this.dragMode;
            if (mode == DragDropMode.Auto)
            {
                mode = this.GetDefaultDragMode(context);
            }

            if (mode == DragDropMode.Immediate)
            {
                if (this.dragContext == DragDropContext.DocumentWindow &&
                    !this.DockManager.TreatTabbedDocumentsAsToolWindows)
                {
                    mode = DragDropMode.Preview;
                }
            }

            return mode;
        }

        private void UpdateAllowedDockStates()
        {
            switch(this.dragContext)
            {
                case DragDropContext.DocumentWindow:
                    if (this.DockManagerDesignMode)
                    {
                        this.currentAllowedStates = AllowedDockState.TabbedDocument;
                        break;
                    }

                    if (this.DockManager.TreatTabbedDocumentsAsToolWindows)
                    {
                        this.currentAllowedStates = this.allowedStates;
                    }
                    else
                    {
                        this.currentAllowedStates = AllowedDockState.TabbedDocument;
                    }
                    break;
                default:
                    if (this.DockManagerDesignMode)
                    {
                        this.currentAllowedStates = AllowedDockState.Docked;
                        break;
                    }

                    this.currentAllowedStates = this.allowedStates;
                    break;
            }
        }

        private bool CanStartImmediateDrag(object context)
        {
            if(this.dragContext == DragDropContext.DocumentWindow &&
                !this.DockManager.TreatTabbedDocumentsAsToolWindows)
            {
                return false;
            }

            if (this.dragContext == DragDropContext.FloatingWindow)
            {
                return true;
            }

            List<DockWindow> windows = null;
            DockTabStrip strip = null;

            switch(this.dragContext)
            {
                case DragDropContext.ToolTabStrip:
                    strip = context as DockTabStrip;
                    break;
                case DragDropContext.ToolWindow:
                case DragDropContext.DocumentWindow:
                    DockWindow window = context as DockWindow;
                    strip = window.DockTabStrip;
                    break;
            }

            Debug.Assert(strip != null);
            windows = ControlHelper.GetChildControls<DockWindow>(strip);

            for (int i = 0; i < windows.Count; i++)
            {
                DockWindow window = windows[i];
                if (!this.DockManager.CanChangeWindowState(window, DockState.Floating, false))
                {
                    windows.RemoveAt(i--);
                }
            }

            return windows.Count > 0;
        }

        private bool CanStartPreviewDrag(object context)
        {
            return true;
        }

        private void MakeFloating(object context)
        {
            Size floatSize = this.GetFloatingSize(context);
            Point floatLocation = this.GetFloatingLocation(context, floatSize);
            Rectangle bounds = new Rectangle(floatLocation, floatSize);
            this.MakeFloating(context, bounds);
        }

        private void MakeFloating(object context, Rectangle bounds)
        {
            IEnumerable<DockWindow> associatedWindows;
            DockWindow firstWindow;
            if (context is DockWindow)
            {
                DockWindow window = (DockWindow)context;
                associatedWindows = new DockWindow[] { window };
                firstWindow = window;
                this.DockManager.FloatWindows(associatedWindows, bounds);
            }
            else
            {
                ToolTabStrip strip = (ToolTabStrip)context;
                associatedWindows = ControlHelper.GetChildControls<DockWindow>(strip);
                firstWindow = strip.ActiveWindow;
                this.DockManager.FloatToolTabStrip(strip, bounds);
            }

            this.DockManager.FlushTransactions();

            this.draggedWindow = firstWindow.FloatingParent;
            this.draggedPaneInitialLocation = bounds.Location;
        }

        private Point GetFloatingLocation(object context, Size floatSize)
        {
            Point location = this.dragStart.Value;
            if (context is DockWindow)
            {
                location = new Point(location.X - floatSize.Width / 2, location.Y - (SystemInformation.CaptionHeight / 2));
            }
            else if (context is DockTabStrip)
            {
                ToolTabStrip strip = context as ToolTabStrip;
                if (strip != null)
                {
                    Rectangle captionBounds = strip.RectangleToScreen(strip.CaptionElement.ControlBoundingRectangle);
                    int offsetX = captionBounds.X - location.X;
                    int offsetY = captionBounds.Y - location.Y;

                    float scaleFactor = floatSize.Width / (float)captionBounds.Width;

                    location = new Point(location.X + (int)(offsetX * scaleFactor), location.Y + offsetY);
                }
            }
            else
            {
                FloatingWindow floatingWindow = context as FloatingWindow;
                if (floatingWindow != null)
                {
                    location = floatingWindow.Location;
                }
            }

            //clamp bottom-right
            location.X = Math.Min(this.dragStart.Value.X + floatSize.Width, location.X);
            location.Y = Math.Min(this.dragStart.Value.Y + SystemInformation.CaptionHeight, location.Y);

            return location;
        }

        private Size GetFloatingSize(object context)
        {
            if (context is FloatingWindow)
            {
                return (context as FloatingWindow).Size;
            }

            Size floatSize = FloatingWindow.DefaultFloatingSize;
            DockWindow window = context as DockWindow;
            if (window == null)
            {
                window = (context as DockTabStrip).ActiveWindow;
            }

            if (window == null)
            {
                return floatSize;
            }

            floatSize = window.DefaultFloatingSize;

            RedockService service = this.DockManager.GetService<RedockService>(ServiceConstants.Redock);
            if (service == null || !service.CanOperate())
            {
                return floatSize;
            }

            RedockFloatingState state = service.GetState(window, DockState.Floating, false) as RedockFloatingState;
            if (state != null && state.FloatingWindow != null)
            {
                floatSize = state.FloatingWindow.Size;
            }

            return floatSize;
        }

        private DragDropTransaction CreateTransaction(SplitPanel target)
        {
            DockPosition position = this.guideHitTest.DockPosition.Value;
            DragDropTransaction transaction;
            DockState state = this.DockManager.GetDockState(target);

            switch (this.currentDragMode)
            {
                case DragDropMode.Preview:
                    switch (this.dragContext)
                    {
                        case DragDropContext.FloatingWindow:
                            FloatingWindow floatWindow = this.Context as FloatingWindow;
                            Debug.Assert(floatWindow != null, "Invalid drag-drop commit state");
                            transaction = new DragDropTransaction(state, null, floatWindow.DockContainer, target, position);
                            break;
                        case DragDropContext.ToolTabStrip:
                            transaction = new DragDropTransaction(state, null, this.Context as DockTabStrip, target, position);
                            break;
                        default:
                            transaction = new DragDropTransaction(state, this.Context as DockWindow, null, target, position);
                            break;
                    }
                    break;
                default:
                    if (this.dragContext == DragDropContext.DocumentWindow)
                    {
                        transaction = new DragDropTransaction(DockState.TabbedDocument, this.Context as DockWindow, null, target, position);
                    }
                    else
                    {
                        transaction = new DragDropTransaction(state, null, this.draggedWindow.DockContainer, target, position);
                    }
                    break;
            }

            return transaction;
        }

        private void RecreateGuides()
        {
            if (this.Disposing || this.IsDisposed)
            {
                return;
            }

            this.RecreateDockingGuides();
            this.RecreateHintPopup();
            this.RecreatePreviewPopup();

            EventHandler eh = this.Events[GuidesRecreatedEventKey] as EventHandler;
            if (eh != null)
            {
                eh(this, EventArgs.Empty);
            }
        }

        /// <summary>
        /// Internal event, used for testing purposes.
        /// </summary>
        internal event EventHandler GuidesRecreated
        {
            add
            {
                this.Events.AddHandler(GuidesRecreatedEventKey, value);
            }
            remove
            {
                this.Events.RemoveHandler(GuidesRecreatedEventKey, value);
            }
        }

        #endregion

        #region Docking Guides/Hints

        private void RecreateHintPopup()
        {
            if (this.hintPopup != null)
            {
                this.hintPopup.Dispose();
                this.hintPopup = null;
            }

            if (this.DockManager != null)
            {
                this.hintPopup = new DockingHintPopup();
                this.hintPopup.Initialize(this.DockManager.DockingGuidesTemplate);
            }
        }

        private void RecreatePreviewPopup()
        {
            if (this.dragPreview != null)
            {
                this.dragPreview.Dispose();
                this.dragPreview = null;
            }

            if (this.DockManager != null)
            {
                this.dragPreview = new DockingHintPopup();
                this.dragPreview.Initialize(this.DockManager.DockingGuidesTemplate);
            }
        }

        private void RecreateDockingGuides()
        {
            if (this.dockingGuides != null)
            {
                foreach (DockingGuidePopup popup in this.dockingGuides)
                {
                    popup.Dispose();
                }
                this.dockingGuides = null;
            }

            if (this.DockManager == null)
            {
                return;
            }

            this.dockingGuides = new DockingGuidePopup[5];
            int index = 0;

            foreach (DockingGuidesPosition position in Enum.GetValues(typeof(DockingGuidesPosition)))
            {
                this.dockingGuides[index++] = new DockingGuidePopup(this, position);
            }
        }

        private void UpdateDockingHint()
        {
            this.UpdateDragPreview();

            if (this.guideHitTest.IsEmpty())
            {
                this.hintPopup.Hide();
                return;
            }

            int hintRatio = 1;
            Rectangle targetBounds;

            if (this.guideHitTest.GuidePosition == DockingGuidesPosition.Center)
            {
                if (this.dropAnchor != null)
                {
                    hintRatio = 2;
                    targetBounds = this.dropAnchor.Parent.RectangleToScreen(this.dropAnchor.Bounds);
                }
                else
                {
                    targetBounds = Rectangle.Empty;
                }
            }
            else
            {
                hintRatio = 3;
                targetBounds = this.DockManager.RectangleToScreen(this.DockManager.ContentRectangle);
            }

            Rectangle hintBounds = Rectangle.Empty;
            int width = targetBounds.Width / hintRatio;
            int height = targetBounds.Height / hintRatio;

            switch (this.guideHitTest.DockPosition)
            {
                case DockPosition.Fill:
                    hintBounds = targetBounds;
                    break;
                case DockPosition.Left:
                    hintBounds = new Rectangle(targetBounds.X, targetBounds.Y, width, targetBounds.Height);
                    break;
                case DockPosition.Right:
                    hintBounds = new Rectangle(targetBounds.Right - width, targetBounds.Y, width, targetBounds.Height);
                    break;
                case DockPosition.Top:
                    hintBounds = new Rectangle(targetBounds.X, targetBounds.Y, targetBounds.Width, height);
                    break;
                case DockPosition.Bottom:
                    hintBounds = new Rectangle(targetBounds.X, targetBounds.Bottom - height, targetBounds.Width, height);
                    break;
            }

            if (hintBounds == Rectangle.Empty)
            {
                this.hintPopup.Hide();
            }
            else
            {
                this.hintPopup.SuspendUpdates();
                this.hintPopup.Location = hintBounds.Location;
                this.hintPopup.DesiredSize = hintBounds.Size;
                this.hintPopup.ResumeUpdates(true);

                //put docking guides on top of the z-order
                foreach (DockingGuidePopup guide in this.dockingGuides)
                {
                    if (guide.Visible)
                    {
                        guide.BringToFront(false);
                    }
                }
            }
        }

        /// <summary>
        /// Updates the drag preview popup when the drag mode is DragDropMode.Preview
        /// </summary>
        private void UpdateDragPreview()
        {
            if (this.currentDragMode != DragDropMode.Preview || 
                (this.currentAllowedStates & AllowedDockState.Floating) == 0)
            {
                return;
            }

            if (!this.guideHitTest.IsEmpty())
            {
                this.dragPreview.Hide();
            }
            else
            {
                this.dragPreview.ShowWindow(this.GetDragLocation());
            }
        }

        private DockingGuidePopup GetPopup(DockingGuidesPosition position)
        {
            foreach (DockingGuidePopup popup in this.dockingGuides)
            {
                if (popup.Position == position)
                {
                    return popup;
                }
            }

            return null;
        }

        private void HideGuides()
        {
            foreach (DockingGuidePopup popup in this.dockingGuides)
            {
                popup.Hide();
            }
        }

        private void HitTestGuides()
        {
            this.guideHitTest = DockingGuideHitTest.Empty;

            //start from the back (Center guide is tested first)
            int count = this.dockingGuides.Length;
            for (int i = count - 1; i >= 0; i--)
            {
                this.guideHitTest = this.dockingGuides[i].HitTest(this.currMouse);
                if (!this.guideHitTest.IsEmpty())
                {
                    break;
                }
            }

            //allow listeners to preview and optionally modify the generated hittest result
            DragDropHitTestEventHandler eh = this.Events[HitTestEventKey] as DragDropHitTestEventHandler;
            if (eh != null)
            {
                DragDropHitTestEventArgs e = new DragDropHitTestEventArgs(this.dropAnchor, this.guideHitTest);
                eh(this, e);
                this.guideHitTest = e.HitTest;
            }
        }

        #endregion

        #region Properties

        /// <summary>
        /// Determines what of the owning <see cref="RadDock">RadDock</see> instance's edges will be allowed for drop.
        /// </summary>
        public AllowedDockPosition AllowedDockManagerEdges
        {
            get
            {
                return this.dockManagerEdges;
            }
            set
            {
                this.dockManagerEdges = value;
            }
        }

        /// <summary>
        /// Gets or sets the mode used by the service to perform drag-and-drop operations.
        /// </summary>
        public DragDropMode DragDropMode
        {
            get
            {
                return this.dragMode;
            }
            set
            {
                this.dragMode = value;
            }
        }

        /// <summary>
        /// Gets or sets the behavior of the service when it is running.
        /// Allows for specifying manual behavior, which enables service automation.
        /// </summary>
        [DefaultValue(DragDropBehavior.Auto)]
        [Description("Gets or sets the behavior of the service when it is running. Allows for specifying manual behavior, which enables service automation.")]
        public DragDropBehavior DragDropBehavior
        {
            get
            {
                return this.behavior;
            }
            set
            {
                this.behavior = value;
            }
        }

        /// <summary>
        /// Gets or sets the allowed states for committing drag-and-drop operation.
        /// </summary>
        public AllowedDockState AllowedStates
        {
            get
            {
                return this.allowedStates;
            }
            set
            {
                this.allowedStates = value;
            }
        }

        /// <summary>
        /// Gets the target of the drop operation.
        /// This member is valid only while the service is started and may be null.
        /// </summary>
        public SplitPanel DropAnchor
        {
            get
            {
                return this.dropAnchor;
            }
        }

        /// <summary>
        /// Gets the hit-test result of the current drag-drop operation.
        /// Valid only while the service is started.
        /// </summary>
        public DockingGuideHitTest HitTestResult
        {
            get
            {
                return this.guideHitTest;
            }
        }

        /// <summary>
        /// Gets the DragDropContext value, which defines what is the current drag context.
        /// </summary>
        public DragDropContext DragDropContext
        {
            get
            {
                return this.dragContext;
            }
        }

        #endregion

        #region Fields

        private Point? dragStart;
        private Point draggedPaneInitialLocation;
        private Point currMouse;
        private Point prevMouse;
        private FloatingWindow draggedWindow;
        private SplitPanel dropAnchor;
        private DockingGuideHitTest guideHitTest;
        private bool messageFilterAdded;
        private AllowedDockPosition dockManagerEdges;
        private DragDropContext dragContext;
        private DragDropMode dragMode;
        private DragDropBehavior behavior;
        private DragDropMode currentDragMode;
        private AllowedDockState allowedStates;
        private AllowedDockState currentAllowedStates;

        private DockingHintPopup dragPreview;//a semi-transparent popup window, indicating a preview drag operation
        private DockingHintPopup hintPopup;
        private DockingGuidePopup[] dockingGuides;

        private static readonly Cursor DocumentDragValid;
        private static readonly Cursor DocumentDragInvalid;
        private static readonly object DraggingEventKey;
        private static readonly object HitTestEventKey;
        private static readonly object DragDropTargetEventKey;
        private static readonly object AllowedDockPositionEventKey;
        private static readonly object GuidesRecreatedEventKey;

        #endregion
    }
}
